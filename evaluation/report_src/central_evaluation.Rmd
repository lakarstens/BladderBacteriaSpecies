---
title: "evaluation functions"
author: "Carter Hoffman"
date: "_last edited `r Sys.Date()`_"

header-includes:
   - \usepackage{amsmath,amssymb}
   - \usepackage[bitstream-charter]{mathdesign}
   - \usepackage[T1]{fontenc}
   
output: 
  html_document:
      toc: true
      toc_depth: 4
      toc_float: true
      theme: readable
      highlight: tango

---
```{r, eval=FALSE, echo=FALSE}
output: 
  pdf_document:
      toc: true
      toc_depth: 2
      df_print: kable
    
output: 
  html_document:
    toc: true
    toc_depth: 4
    toc_float: true
    theme: readable
    highlight: tango

# knit directly to md for github
output:
  md_document:
    variant: gfm
```

```{r echo=FALSE}
knitr::opts_chunk$set(tidy = FALSE, warning = FALSE, message = FALSE, max.print = 5)
```

```{r echo=FALSE}
# load libraries
library(tidyverse)
library(broom)
library(lubridate)
```


# functions


```{r}
#---------------------------#
#   functions!              #
#---------------------------#

# from stackoverflow https://stackoverflow.com/questions/38351820/negation-of-in-in-r
# it was easier to define a not-in function than redo all those lists
`%notin%` <- Negate(`%in%`)

list_of_df <- function(path_to_dir, prefix) {
  # got tired of loading all the csv files individually, 
  # so this function does it in batch. Reads all filenames 
  # in a dir, then creates a df from the csv, then adds names 
  # to the growing list of dataframes.
  get_filenames <- list.files(path_to_dir, full.names = TRUE)
  build_csv_df <- lapply(get_filenames, read.csv, stringsAsFactors=FALSE)

  grow_names <- vector()
  for (g in get_filenames) {
    new_name <- paste(prefix, strsplit(basename(g), "_")[[1]][3], strsplit(basename(g), "_")[[1]][5], sep="_")
    grow_names <- c(grow_names, new_name)
  }
  names(build_csv_df) <- grow_names
  return(build_csv_df)
}

f1_records <- function(results, db, vr, clsfr) {
     #print(sprintf("%s confidence values", length(unique(results$confidence))))
  # was a little lazy with the column names
  # after the python script is done reformatting classification
  # results to something that can be imported as a df, 
  # the classifer column is labled 'blca', whether it's blca or nb.
  
  # these are lists of the species missing from each reference database
  # in order to calculate the number of missed matches correctly
  gg_missing <- c('Actinotignum schaalii', 'Actinomyces naeslundii', 'Actinomyces neuii subsp. anitratus', 'Actinomyces odontolyticus', 'Actinomyces turicensis', 'Actinomyces urogenitalis DSM 15434', 'Aerococcus christensenii', 'Aerococcus sanguinicola', 'Aerococcus urinae', 'Alloscardovia omnicolens', 'Anaerococcus octavius', 'Bacillus idriensis', 'Bacillus infantis', 'Brevibacterium ravenspurgense', 'Corynebacterium amycolatum', 'Corynebacterium coyleae', 'Corynebacterium matruchotii ATCC 14266', 'Corynebacterium pyruviciproducens ATCC BAA-1742', 'Corynebacterium riegelii', 'Corynebacterium tuscaniense', 'Dermabacter hominis', 'Enterobacter asburiae', 'Enterobacter cloacae subsp. cloacae ATCC 13047', 'Enterococcus faecalis', 'Escherichia coli', 'Facklamia hominis CCUG 36813', 'Facklamia ignava', 'Gardnerella vaginalis ATCC 14018 = JCM 11026', 'Globicatella sanguinis', 'Gordonia terrae', 'Klebsiella pneumoniae', 'Kytococcus schroeteri', 'Lactobacillus crispatus', 'Lactobacillus fermentum', 'Lactobacillus gasseri', 'Lactobacillus jensenii', 'Lactobacillus johnsonii', 'Lactobacillus rhamnosus', 'Moraxella osloensis', 'Neisseria macacae', 'Neisseria perflava', 'Oligella urethralis', 'Propionibacterium avidum ATCC 25577', 'Proteus mirabilis', 'Pseudomonas aeruginosa', 'Staphylococcus hominis subsp. hominis', 'Staphylococcus saprophyticus subsp. saprophyticus ATCC 15305', 'Staphylococcus simulans', 'Staphylococcus warneri', 'Streptococcus equinus', 'Streptococcus gordonii', 'Streptococcus mitis', 'Streptococcus oralis ATCC 35037', 'Streptococcus parasanguinis', 'Streptococcus salivarius subsp. salivarius', 'Streptococcus sanguinis', 'Trueperella bernardiae', 'Varibaculum cambriense')
  
  custom_missing <- c('Bacillus idriensis', 'Corynebacterium species')
  
  ncbi_gen_missing <- c('Actinomyces naeslundii', 'Anaerococcus octavius', 'Bacillus idriensis', 'Corynebacterium amycolatum', 'Dermabacter hominis', 'Enterobacter asburiae', 'Globicatella sanguinis', 'Kytococcus schroeteri', 'Lactobacillus johnsonii', 'Neisseria macacae', 'Neisseria perflava', 'Neisseria subflava', 'Streptococcus oralis ATCC 35037', 'Corynebacterium species')

  
  # set up some variables
  ranger <- data.frame()
  
  # need to multiply the qiime confidence levels by 100
  if (clsfr=="blca") {
    results$confidence <- results$confidence / 100
  }

  for (x in seq(0,1,.001)) {
    #print(sprintf("working on %s", x))
    # seperate the confusion matrix cells first
    
    # True Matches:
    #   if the query and reference are the same name, 
    #   and the confidence value is greater than the threshold 
    #   if species isn't in DB, it never gets assigned as match 
    cell_d <- ifelse((results$match==1 & results$confidence >= x), 1, 0)
    
    # False Matches:
    #   if the query and reference are not the same name, 
    #   and the confidence value is greater than the threshold
    #   doesn't matter if the species is in the DB or not
    cell_b <- ifelse((results$match==0 & results$confidence >= x), 1, 0)
    
    # updating this
    # instead of creating a logical vector, loading the missing species
    # list into a variable that gets used when calculating cellC
    if (db=="gg") {
      # greengenes database
      # make a column showing if the query is in the database or not
      #results$attendence <- results$query %notin% gg_missing
      check_for_attendence <- gg_missing
      
    } else if (db=="genomic") {
      # ncbi genomic database
      # left this functionality in for now, 
      # but it's for a section of the project that didn't make it into the manuscript
      
      # make a column showing if the query is in the database or not
      #results$attendence <- results$query %notin% ncbi_gen_missing
      check_for_attendence <- ncbi_gen_missing
      
    } else if (db=="custom") {
      # the custom genomic database
      # left this functionality in for now, 
      # but it's for a section of the project that didn't make it into the manuscript
      
      # make a column showing if the query is in the database or not
      #results$attendence <- results$query %notin% custom_missing
      check_for_attendence <- custom_missing
      
    } else {
      #results$attendence <- TRUE
      check_for_attendence <- c("allgood")
    }
    
    # now for these two conditionals
    # checking if an element in the logical vector was failing and I didn't see it
    # the %notin% will evaluate to true or false
    
    # There are only two ways for a missed match (missed matches are called false non-matches in the manuscript)
    #    1) a known true match is missed and another record is assigned as a match
    #    2) a true match that is below the confidence score, AKA a false match when the species is in the database
    
    # missed match below threshold:
    #   if the species is in the DB
    #   and match==1
    #   and below the confidence score
    missed_match_below <- ifelse((results$confidence < x & results$match==1 & (results$query %notin% check_for_attendence)), 1,0)
    
    # missed match above threshold:
    #   if the query is in the database 
    #   and match==0
    #   and above the confidence score, 
    #   then there needs to be a corresponding missed match
    #   but if it's below the conf score, it's only a MM
    missed_match_above <- ifelse((results$match==0 & (results$query %notin% check_for_attendence)), 1, 0) 

    cell_c <- missed_match_below + missed_match_above
    
    # add cell counts to results dataframe
    results_confusion <- cbind(results, cell_b,cell_c,cell_d)
    
    w <- (sum(results_confusion$cell_d) + sum(results_confusion$cell_c)) / (sum(results_confusion$cell_b) + sum(results_confusion$cell_c) + 2*sum(results_confusion$cell_d))
    get_recall <- sum(results_confusion$cell_d)/(sum(results_confusion$cell_c) + sum(results_confusion$cell_d))
    get_precision <- sum(results_confusion$cell_d)/(sum(results_confusion$cell_b) + sum(results_confusion$cell_d))
    wr <- w*get_recall
    wp <- (1-w)*get_precision
    f1 <- (w*get_recall) + ((1-w)*get_precision)
    
    # replace 'region' names with more informative ones
    if (vr=="v3") {
      variable_region <- "V3"
    } else if (vr=="v6") {
      variable_region <- "V6"
    } else if (vr=="k17") {
      variable_region <- "V1-V3"
    } else if (vr=="bbv") {
      variable_region <- "V2-V3"
    } else if (vr=="cap") {
      variable_region <- "V4" 
    } else if (vr=="k515") {
      variable_region <- "V4-V6"
    } else if (vr=="b646") {
      variable_region <- "V3-V5"
    } else if (vr=="ffh") {
      variable_region <- "Ffh V1-V2"
    } else if (vr=="rpob") {
      variable_region <- "RpoB V1"
    } else {
      variable_region <- "V3-V4"
    }
    
    # replace database
    if (db=="gg") {
      the_db <- "Greengenes"
    } else if (db=="silva") {
      the_db <- "Silva"
    } else if (db=="ncbi16") {
      the_db <- "NCBI 16S"
    } else if (db=="genomic") {
      the_db <- "NCBI Genomic"
    } else {
      the_db <- "Custom Genomic"
    }
    
    # replace classifier
    if (clsfr=="blca") {
      the_clsfr <- "BLCA"
    } else {
      the_clsfr <- "Naive Bayes"
    }
  

    small_range <- data.frame(weight=w, recall=get_recall, precision=get_precision, fmeasure=f1, weight_r=wr, weight_p=wp, true_match=sum(results_confusion$cell_d) , false_match=sum(results_confusion$cell_b), database=the_db, classifier=the_clsfr, region=variable_region, confidence=x, cellC=sum(results_confusion$cell_c))
    small_range$confidence <- x
    ranger <- rbind(ranger, small_range)
  }

  return(ranger)
}

total_results <- function(each_result) {

  each_name <- names(each_result)
  
  final_db <- data.frame()
  for (x in each_name) {
    the_classifier <- strsplit(x, split="_")[[1]][1]
    the_var_region <- strsplit(x, split="_")[[1]][2]
    the_db <- strsplit(x, split="_")[[1]][3]
    #message(sprintf("sending to f1: name=%s, database=%s, vr=%s, classifier=%s", x, the_db, the_var_region, the_classifier))
    holder <- f1_records(each_result[x][[1]], the_db, the_var_region, the_classifier)
    final_db <- rbind(final_db, holder)
  }
  return(final_db)
}


```

# ribosome

```{r, eval=FALSE}
blca_gg_results <- list_of_df("../../taxonomy/processed_files/blca_validated_outfiles_2020-03-09_18/gg/", "blca")
blca_silva_results <- list_of_df("../../taxonomy/processed_files/blca_validated_outfiles_2020-03-09_18/silva/", "blca")
blca_ncbi16_results <- list_of_df("../../taxonomy/processed_files/blca_validated_outfiles_2020-03-09_18/ncbi16/", "blca")

qiime_gg_results <- list_of_df("../../taxonomy/processed_files/qiime_validated_outfiles_2020-03-09_19/gg/", "qiime")
qiime_silva_results <- list_of_df("../../taxonomy/processed_files/qiime_validated_outfiles_2020-03-09_19/silva/", "qiime")
qiime_ncbi16_results <- list_of_df("../../taxonomy/processed_files/qiime_validated_outfiles_2020-03-09_19/ncbi16/", "qiime")

all_species_16s_results <- c(blca_gg_results, blca_silva_results, blca_ncbi16_results, qiime_gg_results, qiime_silva_results, qiime_ncbi16_results)
all_species_16s_evaluation <- total_results(all_species_16s_results)

```

```{r, eval=FALSE}
# save them
runtime <- paste(Sys.Date(), hour(Sys.time()), minute(Sys.time()), sep='-')
saveRDS(all_species_16s_evaluation, paste0("../processed_files/all_species_16s_evaluation_", runtime, ".rds"))
```

all_species_16s_evaluation_2020-06-03-12-36.rds is before the fix for the MM

all_species_16s_evaluation_2020-06-03-14-32 is after



# filter by just the gg species

This section involves comparing the classification schemes when all databases were screened to just include the species in the Greengenes database. It didn't make it into the publication.

```{r}
all_species_16s_results$blca_b646_ncbi16 %>% filter(query %notin% gg_missing)
```

```{r, eval=FALSE}
dumb_down_to_gg <- function(each_result) {
    gg_missing <- c('Actinotignum schaalii', 'Actinomyces naeslundii', 'Actinomyces neuii subsp. anitratus', 'Actinomyces odontolyticus', 'Actinomyces turicensis', 'Actinomyces urogenitalis DSM 15434', 'Aerococcus christensenii', 'Aerococcus sanguinicola', 'Aerococcus urinae', 'Alloscardovia omnicolens', 'Anaerococcus octavius', 'Bacillus idriensis', 'Bacillus infantis', 'Brevibacterium ravenspurgense', 'Corynebacterium amycolatum', 'Corynebacterium coyleae', 'Corynebacterium matruchotii ATCC 14266', 'Corynebacterium pyruviciproducens ATCC BAA-1742', 'Corynebacterium riegelii', 'Corynebacterium tuscaniense', 'Dermabacter hominis', 'Enterobacter asburiae', 'Enterobacter cloacae subsp. cloacae ATCC 13047', 'Enterococcus faecalis', 'Escherichia coli', 'Facklamia hominis CCUG 36813', 'Facklamia ignava', 'Gardnerella vaginalis ATCC 14018 = JCM 11026', 'Globicatella sanguinis', 'Gordonia terrae', 'Klebsiella pneumoniae', 'Kytococcus schroeteri', 'Lactobacillus crispatus', 'Lactobacillus fermentum', 'Lactobacillus gasseri', 'Lactobacillus jensenii', 'Lactobacillus johnsonii', 'Lactobacillus rhamnosus', 'Moraxella osloensis', 'Neisseria macacae', 'Neisseria perflava', 'Oligella urethralis', 'Propionibacterium avidum ATCC 25577', 'Proteus mirabilis', 'Pseudomonas aeruginosa', 'Staphylococcus hominis subsp. hominis', 'Staphylococcus saprophyticus subsp. saprophyticus ATCC 15305', 'Staphylococcus simulans', 'Staphylococcus warneri', 'Streptococcus equinus', 'Streptococcus gordonii', 'Streptococcus mitis', 'Streptococcus oralis ATCC 35037', 'Streptococcus parasanguinis', 'Streptococcus salivarius subsp. salivarius', 'Streptococcus sanguinis', 'Trueperella bernardiae', 'Varibaculum cambriense')

  each_name <- names(each_result)
  
  final_db <- data.frame()
  for (x in each_name) {
    the_classifier <- strsplit(x, split="_")[[1]][1]
    the_var_region <- strsplit(x, split="_")[[1]][2]
    the_db <- strsplit(x, split="_")[[1]][3]
    #message(sprintf("sending to f1: name=%s, database=%s, vr=%s, classifier=%s", x, the_db, the_var_region, the_classifier))
    holder <- f1_records(each_result[x][[1]] %>% filter(query %notin% gg_missing), the_db, the_var_region, the_classifier)
    final_db <- rbind(final_db, holder)
  }
  return(final_db)
}

dumber_all_species_16s_evaluation <- dumb_down_to_gg(all_species_16s_results)
```

```{r, eval=FALSE}
# save them
runtime <- paste(Sys.Date(), hour(Sys.time()), minute(Sys.time()), sep='-')
saveRDS(dumber_all_species_16s_evaluation, paste0("../processed_files/dumber_all_species_16s_evaluation_", runtime, ".rds"))
```

```{r}
#all_species_16s_results$blca_b646_ncbi16$query
```







